\documentclass{article}
\documentclass[utf8x, 12pt]{G7-32} % Стиль (по умолчанию будет 14pt)
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{mathtext}
\usepackage[numberright]{eskdplain}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathtext}
\usepackage[T1,T2A]{fontenc}
\usepackage[english,bulgarian,ukranian,russian]{babel}
\usepackage[argument]{graphicx}
\graphicspath{{pics/}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\usepackage{geometry} % Меняем поля страницы
\geometry{left=2cm}% левое поле
\geometry{right=1.5cm}% правое поле
\geometry{top=1cm}% верхнее поле
\geometry{bottom=2cm}% нижнее поле

\begin{document}
    \begin{center} 
    \large МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ

федеральное государственное автономное образовательное учреждение высшего образования

\textbf{Национальный исследовательский нижегородский государственный университет им. Н.И. Лобачевского}

Институт информационных технологий, математики и механики \\
\textbf{Кафедра математического обеспечения и суперкомпьютерных технологий}\\[3.5cm] 
    
    \huge \textbf{Отчёт по практике} \\[0.6cm] % название работы, затем отступ 0,6см
    \\ 
    \huge{На тему :}\\[0.6cm]
    \huge \textbf{Разработка и оптимизация программ под MyriadX и Keem Bay VPU}\\[5.7cm]
    
    
    \end{center} 
    
    \begin{flushright}
    \large \textbf{Выполнил:} 
    студент гр. 381706-1 \\
    Митягина Дарья Сергеевна \\ [0.65cm]
    --------------------------------------\\
                                Подпись\\
    \textbf{Научный руководитель:} \\
    Профессор, доктор технических наук\\
    Турлапов Вадим Евгеньевич \\ [0.65cm]
    --------------------------------------\\
                                Подпись\\
    [3.2cm]
    \end{flushright}
    
    % \vfill 
    
    \begin{center} 
    \large Нижний Новгород 2020
    \end{center} 

    % \thispagestyle{empty}
    \newpage
      \begin{center}
    %   Содержание
      \end{center}
        \tableofcontents
      
    \newpage
    \begin{center} 
    \section{Введение}
    %   \huge \textbf{Введение} \\[1.3cm]
    \end{center}
    \large 
    
    Эффективное использование ускорителей глубокого обучения является важной частью продуктивного использования искусственного интеллекта (далее ИИ).
    
    Чтобы преодолеть проблемы с ограниченной производительностью в одноядерных однопроцессорных системах, стали популярными параллельные компьютерные системы с несколькими процессорами (или несколькими процессорными ядрами).
    
    Однако в работе с подобными устройствами есть и некоторые труности. Программирование параллельных приложений часто представляет собой более сложную задачу, чем программирование последовательных приложений. А значит, параллельные компьютерные системы часто требуют, чтобы программист заботился о деталях низкого уровня, которые могут различаться между разными системы.\\ \\
    Целью данной работы является :\\
    \begin{enumerate} 
    \item обзор существующих аппаратных решений в области deep learning'а
    \item детальный обзор архитектуры Myriad X VPU
    \item описание принципов программирования под эту платформу
    \item результатов некоторых проведенных экспериментов
    \end{enumerate} 
    \\
    
    \newpage
    \begin{center} 
    \section{Выбор аппаратного обеспечения}
    \end{center}
    
    Глубокое обучение требует больших вычислительных ресурсов, поэтому очень важно, какое аппаратное обеспечение будет выберано для исследований. Рассмотрим возможные варианты.
    
    Существует множество видов процессоров, но не все подходят для быстрой и эффективной работы с нейросетями.\\
    \begin{enumerate} 
    \item 
    Графический процессор (graphics processing unit, GPU) — отдельное устройство персонального компьютера или игровой приставки, выполняющее графический рендеринг; в начале 2000-х годов графические процессоры стали массово применяться и в других устройствах: планшетные компьютеры, встраиваемые системы, цифровые телевизоры.
    
    Современные графические процессоры очень эффективно обрабатывают и отображают компьютерную графику, благодаря специализированной конвейерной архитектуре они намного эффективнее в обработке графической информации, чем типичный центральный процессор.
    
    Высокая вычислительная мощность GPU объясняется особенностями архитектуры. Современные CPU содержат небольшое количество ядер, тогда как графический процессор изначально создавался как многопоточная структура с множеством ядер. Разница в архитектуре обусловливает и разницу в принципах работы. 
    \item 
    Тензорный процессор (tensor processing unit, TPU) — тензорный процессор, относящийся к классу нейронных процессоров, являющийся специализированной интегральной схемой.
    
    По сравнению с графическими процессорами, рассчитан на более высокий объём вычислений с пониженной точностью (например, всего 8-разрядную точность).
    
    Устройство реализовано как матричный умножитель для 8-разрядных чисел, управляемый CISC-инструкциями центрального процессора по шине PCIe 3.0. Изготавливается по технологии 28 нм, тактовая частота составляет 700 МГц и имеет тепловую расчётную мощность 28—40 Вт. Оснащается 28 Мбайт встроенной оперативной памяти и 4 Мбайт 32-разрядных аккумуляторов, накапливающих результаты в массивах из 8-битных множителей, организованных в матрицу размером 256×256. Инструкции устройства передают данные на узел или получают их из него, выполняют матричные умножения или свёртки. В такт может производиться 65536 умножений на каждой матрице; в секунду — до 92 трлн.
    \item
    Программируемая пользователем вентильная матрица(field-programmable gate array, FPGA) — полупроводниковое устройство, которое может быть сконфигурировано производителем или разработчиком после изготовления; наиболее сложная по организации разновидность программируемых логических интегральных схем.
    
    Программируются путём изменения логики работы принципиальной схемы, например, с помощью исходного кода на языке описания аппаратуры. Могут быть модифицированы практически в любой момент в процессе их использования. Cостоят из конфигурируемых логических блоков, подобных переключателям с множеством входов и одним выходом (логические вентили, gates). Принципиальное отличие ППВМ состоит в том, что и функции блоков, и конфигурация соединений между ними могут меняться с помощью специальных сигналов, посылаемых схеме. В некоторых специализированных интегральных схемах (ASIC) используются логические матрицы, аналогичные ППВМ по строению, однако они конфигурируются один раз в процессе производства, в то время как ППВМ могут постоянно перепрограммироваться и менять топологию соединений в процессе использования.
    \item
    Процессор машинного зрения (vision processing unit, VPU) — новый класс специализированных микропроцессоров являющихся разновидностью ИИ-ускорителей, предназначенных для аппаратного ускорения работы алгоритмов машинного зрения.
    
    VPU во многом похожи на тензорные процессоры, но они узкоспециализированы для ускорения работы алгоритмов машинного зрения, в которых используются методы свёрточных нейронных сетей (CNN) и масштабно-инвариантная трансформация признаков (SIFT). В них делается большой акцент на распараллеливание потока данных между множеством исполнительных ядер, включая использование модели блокнотной памяти — как в многоядерных цифровых сигнальных процессорах, и они так же, как тензорные процессоры, используются для вычислений c низкой точностью, принятой при обработке изображений.\\
    Именно этот вид будет рассмотрен подробнее.
    \end{enumerate} 
    
    \newpage
    \begin{center}
    \section{Архитектура MyriadX VPU}
    \end{center}
    
    \begin{center} 
    \includegraphics[scale=0.6]{arch4.png}
    \\
    \caption{Рис. 1 - схема MyriadX}
    \\ \\
    \end{center} 
    \\
    Особенностями данного устройства являются:
    \begin{enumerate}
    \item Вычислительная система для нейросетей.
    
    Благодаря этому специализированному акселератору на микросхеме для глубинных нейронных сетей, визуальный процессор Intel® Movidius™ Myriad™ X обеспечивает производительность при формировании логических выводов глубинных нейронных сетей более 1 триллиона операций в секунду. Это дает возможность запускать глубинные нейронные сети в режиме реального времени на периферийных устройствах без ущерба для потребления энергии или точности.
    \item 16 программируемых 128-рарядных векторных процессоров VLIW.
    
    Это дает возможность запускать одновременно несколько конвейеров приложений для обработки изображений и видео с использованием 16 вариантов векторных процессоров, оптимизированных для рабочих нагрузок компьютерного зрения.
    \item 16 настраиваемых полос MIPI. 
    
    Это дает возможность подключать до 8 RGB-камер с разрешением HD непосредственно к визуальному процессору Intel® Movidius™ Myriad™ X с поддержкой скорости обработки сигналов изображения до 700 миллионов пикселей в секунду.
    \item Акселераторы расширенного машинного зрения.
    
    Это дает возможность использовать более 20 аппаратных акселераторов для выполнения таких задач, как оптический поток и глубина стерео без дополнительных расходов на вычисления. Например, новый акселератор глубины стерео может одновременно обрабатывать 6 входов камер (3 стереопары), каждый их которых работает при разрешении 720p на частоте кадров 60 Гц.
    \item 2,5 МБ гомогенной памяти на микросхеме. 
    Централизованная архитектура памяти на микросхеме обеспечивает внутреннюю пропускную способность до 400 ГБ/с, что снижает уровень задержек и потребление энергии за счет минимизации переноса данных, которые находятся вне микросхемы.
    \end{enumerate}

    % \begin{center} 
    % \includegraphics[scale=1.5]{arch.jpg}
    % \\ \\
    % \caption{Рис. 2 - }
    % \\
    % \end{center} 
    
    % \newpage
    % продолжение
    % \newpage
    % продолжение
    
    \newpage
    \begin{center}
    \section{Архитектура Keem Bay VPU}
    \end{center}
    
    % \newpage
    % продолжение
    % \newpage
    % продолжение
    
    \newpage
    \begin{center} 
    \section{Принципы программирования под MyriadX и Keem Bay VPU}
    \end{center}
    
    % \newpage
    % продолжение
    % \newpage
    % продолжение
    
    \newpage
    \begin{center} 
    \section{Краткий обзор источников}
    \end{center}
    
    % \newpage
    % продолжение
    % \newpage
    % продолжение
    % \newpage
    % продолжение
    % \newpage
    % продолжение
    
    \newpage
    \begin{center} 
    \section{Выполненные задачи}
    \huge Interpolate-4
    \end{center}
    \large В данной задаче было необходимо добавить операцию Interpolate-4 в OpenVINO.
    Рассмотрим постановку задачи.
    Краткое описание: слой Interpolate выполняет интерполяцию независимых slices во входном тензоре по заданным размерам и параметрам.\\ Рассмотрим постановку задачи:\\ \\
    \textbf{Параметры}
    \begin{enumerate}
        \item mode\\
        
        \underline{\textit{Описание:}} указывает тип интерполяции\\
        \underline{\textit{Диапазон значений:}} одно из nearest, linear, linearOnnx, cubic\\
        \underline{\textit{Тип:}} string\\
        \underline{\textit{Значение по умолчанию:}} нет\\
        \underline{\textit{Обязательно:}} да\\
        
        \item shape calculation mode\\
        
        \underline{\textit{Описание:}} указывает, какие входные данные, размеры или масштабы используются для расчета выходной формы.\\
        \underline{\textit{Диапазон значений:}} название режима расчета формы в строковом формате:\\
        - sizes - форма вывода рассчитывается как \\
        outputShape[axes[i]] = sizes[i] for all i in range(0, len(axes)) и outputShape[j] = inputShape[j] + padsBegin[j] + padsEnd[j] for j not in axes, j in range(0, rank(data)).\\
        
        - scales - форма вывода рассчитывается как \\
        outputShape[axes[i]] = floor(scales[i] * (inputShape[axes[i]] + padsBegin[axes[i]] + padsEnd[axes[i]])) for all i in range(0, len(axes)) and outputShape[j] = inputShape[j] + padsBegin[j] + padsEnd[j] for j not in axes, j in range(0, rank(data))\\
        \underline{\textit{Тип:}} string\\
        \underline{\textit{Значение по умолчанию:}} нет\\
        \underline{\textit{Обязательно:}} да\\
        
        \item coordinate transformation mode\\
        
        \underline{\textit{Описание:}} указывает, как преобразовать координату в тензоре с измененным размером в координату в исходном тензоре.\\
        \underline{\textit{Диапазон значений:}} название режима преобразования в строковом формате\\
        - halfPixel - the coordinate in the original tensor axis x is calculated as ((xResized + 0.5) / scale[x]) - 0.5.\\
        - pytorchHalfPixel - the coordinate in the original tensor axis x is calculated by (xResized + 0.5) / scale[x] - 0.5 if outputShape[x] > 1 else 0.0.\\
        - asymmetric - the coordinate in the original tensor axis x is calculated according to the formula xResized / scale[x].\\
        - tfHalfPixelForNn - the coordinate in the original tensor axis x is (xResized + 0.5) / scale[x].\\
        - alignCorners - the coordinate in the original tensor axis x is calculated as 0 if outputShape[x] == 1 else xResized * (inputShape[x] - 1) / (outputShape[x] - 1).\\
        \underline{\textit{Тип:}} string\\
        \underline{\textit{Значение по умолчанию:}} halfPixel\\
        \underline{\textit{Обязательно:}} нет\\

        \item nearestMode\\
        
        \underline{\textit{Описание:}} указывает режим округления, когда режим == nearest, и используется только когда режим == nearest.\\
        \underline{\textit{Диапазон значений:}} название режима округления в строковом формате:\\
        - roundPreferFloor - этот режим известен как округление вниз.\\
        - roundPreferCeil - это режим округления вверх.\\
        - floor - в этом режиме вычисляется наибольшее целочисленное значение, не превышающее округленное значение.\\
        - ceil - в этом режиме вычисляется наименьшее целочисленное значение не меньше округленного значения.\\
        - simple - этот режим ведет себя как режим ceil, когда Interpolate - это downsample, и как отбрасывание дробной части в противном случае\\
        \underline{\textit{Тип:}} string\\
        \underline{\textit{Значение по умолчанию:}} roundPreferFloor\\
        \underline{\textit{Обязательно:}} нет\\
        
        \item antialias\\
        
        \underline{\textit{Описание:}} флаг, который указывает, следует ли выполнять сглаживание.\\
        \underline{\textit{Диапазон значений:}}
        False - не выполнять сглаживание\\
        True - выполнять сглаживание\\
        \underline{\textit{Тип:}} boolean\\
        \underline{\textit{Значение по умолчанию:}} False\\
        \underline{\textit{Обязательно:}} нет\\
        
        \item padsBegin\\
        
        \underline{\textit{Описание:}} указывает количество пикселей, добавляемых к началу интерполируемого изображения. Это добавление пикселей выполняется до вычисления интерполяции.\\
        \underline{\textit{Диапазон значений:}}
        список неотрицательных целых чисел\\
        \underline{\textit{Тип:}} int[]\\
        \underline{\textit{Значение по умолчанию:}} [0]\\
        \underline{\textit{Обязательно:}} нет\\
        
        \item padsEnd\\
        
        \underline{\textit{Описание:}} указывает количество пикселей, добавляемых к концу интерполируемого изображения. Это добавление пикселей выполняется до вычисления интерполяции.\\
        \underline{\textit{Диапазон значений:}}
        список неотрицательных целых чисел\\
        \underline{\textit{Тип:}} int[]\\
        \underline{\textit{Значение по умолчанию:}} [0]\\
        \underline{\textit{Обязательно:}} нет\\
        
        \item cubeCoeff\\
        
        \underline{\textit{Описание:}} задает параметр a для кубической интерполяции (см., например, статью). cubeCoeff используется только когда mode == cubic.\\
        \underline{\textit{Диапазон значений:}}
        float\\
        \underline{\textit{Тип:}} любой из поддерживаемых типов с плавающей запятой\\
        \underline{\textit{Значение по умолчанию:}} -0.75\\
        \underline{\textit{Обязательно:}} нет\\
        
    \end{enumerate}
\\ \\ 
\textbf{Входные данные:}\\
    \begin{enumerate}
        \item data - входной тензор с данными для интерполяции. Тип элементов - любой поддерживаемый тип с плавающей запятой или тип int8. Необходимые.\\

        \item sizes - одномерный тензор, описывающий форму вывода для пространственных осей. Количество элементов совпадает с количеством индексов во вводе осей, порядок также совпадает. Необходимые.\\

        \item scales - 1D тензор, описывающий масштабы для пространственных осей. Тип элементов - любой поддерживаемый тип с плавающей запятой. Количество и порядок элементов соответствуют количеству и порядку индексов при вводе осей. Необходимые.\\

        \item axes - одномерный тензор, определяющий индексы размерности, в которых применяется интерполяция, а оси - это любой неупорядоченный список индексов разных размерностей входного тензора, например [0, 4], [4, 0], [4, 2, 1], [1, 2, 3]. Эти индексы должны быть неотрицательными целыми числами от 0 до rank (data) - 1 включительно. Остальные габариты не меняются. Порядок элементов в атрибуте axes имеет значение и отображается непосредственно на элементы во 2-м входном размере. Необязательно со значением по умолчанию [0, ..., rank (data) - 1].\\
    \end{enumerate}
\\ \\ 
\textbf{Выход:}\\
    \begin{enumerate}
        \item Результирующий интерполированный тензор с элементами того же типа, что и тензор входных данных. Форма выходных данных соответствует форме входных данных, за исключением пространственных размеров, указанных в атрибуте axes. Для остальных размеров форма соответствует размерам из размеров в порядке, указанном в осях.
    \end{enumerate}
    
    % \newpage
    % продолжение
    % \newpage
    % продолжение
    % \newpage
    % продолжение
    % \newpage
    % продолжение
    % \newpage
    % продолжение
    
    \newpage
    \begin{center} 
    \section{Заключение}
    \end{center}
    
    % \newpage
    % продолжение
    
    \newpage
    \begin{center} 
    \section{Список литературы}
    \end{center}
    
    \newpage
    \begin{center} 
    \section{Приложение}
    \end{center}
    
    % \newpage
    % продолжение
    % \newpage
    % продолжение
    
    \newpage
    \begin{center} 
    \section{Теоретический минимум}
    \end{center}
    
    % \newpage
    % продолжение
    
\end{document}
